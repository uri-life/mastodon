# URI Mastodon 패치 빌드 워크플로우
# 변경된 버전만 빌드하고, 최신 버전에는 latest 태그 부여
# 각 플랫폼별 네이티브 머신에서 빌드

variables:
  - &registry 'ghcr.io'
  - &organization 'uri-life'
  - &repository-base 'mastodon'

clone:
  git:
    image: woodpeckerci/plugin-git
    settings:
      depth: 2
      partial: false

matrix:
  platform:
    - linux/amd64
    - linux/arm64

labels:
  platform: ${platform}

when:
  - event: push
    branch: main
    path:
      include:
        - 'versions/**'
        - 'manifest.yaml'
  - event: tag
    evaluate: 'CI_COMMIT_TAG matches "v[0-9]+\\\\.[0-9]+\\\\.[0-9]+([^+]+)?\\\\+uri[0-9]+\\\\.[0-9]+"'
  - event: manual
    branch: main

steps:
  # 변경된 버전 감지 및 최신 버전 판단
  - name: detect-versions
    image: alpine:latest
    commands:
      - apk add --no-cache git
      - scripts/detect-versions.sh "../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        # 이벤트 타입에 따른 태그 접미사 설정
        if [ "${CI_PIPELINE_EVENT}" = "tag" ]; then
          echo "IS_RELEASE=true" >> "$ENV_FILE"
          echo "TAG_SUFFIX=" >> "$ENV_FILE"
        else
          echo "IS_RELEASE=false" >> "$ENV_FILE"
          echo "TAG_SUFFIX=-staging" >> "$ENV_FILE"
        fi

  # upstream 클론 및 패치 도구 설치
  - name: setup
    image: ubuntu:latest
    commands:
      - |
        apt update && apt install -y git wget
        # 플랫폼에 맞는 yq 바이너리 다운로드
        case "${platform}" in
          linux/amd64) YQ_ARCH="amd64" ;;
          linux/arm64) YQ_ARCH="arm64" ;;
          *) echo "지원하지 않는 플랫폼: ${platform}"; exit 1 ;;
        esac
        wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_$YQ_ARCH"
        chmod +x /usr/local/bin/yq
        # yq 설치 확인
        if ! /usr/local/bin/yq --version; then
          echo "ERROR: yq 설치 실패"
          exit 1
        fi
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        . "$ENV_FILE"

        if [ -z "$VERSIONS_TO_BUILD" ]; then
          echo "빌드할 버전이 없습니다. 스킵합니다."
          exit 0
        fi

        # manifest.yaml에서 upstream URL 추출
        UPSTREAM_URL=$(grep 'upstream:' manifest.yaml | sed 's/upstream:[[:space:]]*//')
        git clone --depth=1 https://github.com/uri-life/uri.git uri
        chmod +x uri/bin/uri

        # upstream 클론 (태그 정보 포함)
        git clone -q --depth=1 "$UPSTREAM_URL" mastodon
        cd mastodon
        git fetch --tags
        # Git 사용자 정보 설정 (git am에 필요)
        git config user.name "uri.life CI"
        git config user.email "ci@uri.life"
        cd ..

        # 각 버전별로 패치 적용 (브랜치 생성됨: uri/vX.Y.Z/uriX.Y)
        for VERSION_COMBO in $VERSIONS_TO_BUILD; do
          MASTODON_VER=`echo "$VERSION_COMBO" | cut -d: -f1`
          URI_VER=`echo "$VERSION_COMBO" | cut -d: -f2`
          uri/bin/uri apply "$MASTODON_VER" "$URI_VER" mastodon
        done

  # Docker 이미지 빌드
  - name: build
    image: docker:cli
    commands:
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        . "$ENV_FILE"

        if [ -z "$VERSIONS_TO_BUILD" ]; then
          echo "빌드할 버전이 없습니다. 스킵합니다."
          exit 0
        fi

        for VERSION_COMBO in $VERSIONS_TO_BUILD; do
          MASTODON_VER=`echo "$VERSION_COMBO" | cut -d: -f1`
          URI_VER=`echo "$VERSION_COMBO" | cut -d: -f2`

          WORK_DIR="mastodon"
          BRANCH_NAME="uri/$MASTODON_VER/$URI_VER"
          IMAGE_NAME="mastodon-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}-$MASTODON_VER-$URI_VER"
          STREAMING_IMAGE_NAME="mastodon-streaming-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}-$MASTODON_VER-$URI_VER"

          VERSION_METADATA="$URI_VER"

          cd "$WORK_DIR"
          git checkout "$BRANCH_NAME"

          # Mastodon 메인 이미지 빌드
          docker build -t "$IMAGE_NAME:latest" \
            --build-arg MASTODON_VERSION_METADATA="$VERSION_METADATA" \
            --build-arg GITHUB_REPOSITORY="${CI_REPO}" \
            --build-arg SOURCE_BASE_URL="https://github.com/${CI_REPO}" \
            --build-arg SOURCE_TAG="$MASTODON_VER+$URI_VER" \
            .

          # Streaming 이미지 빌드
          docker build -t "$STREAMING_IMAGE_NAME:latest" \
            --build-arg MASTODON_VERSION_METADATA="$VERSION_METADATA" \
            --build-arg GITHUB_REPOSITORY="${CI_REPO}" \
            --build-arg SOURCE_BASE_URL="https://github.com/${CI_REPO}" \
            --build-arg SOURCE_TAG="$MASTODON_VER+$URI_VER" \
            -f streaming/Dockerfile \
            .

          cd -
        done
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  # 이미지 태깅 및 푸시
  - name: push
    image: docker:cli
    environment:
      IMAGE_REGISTRY: *registry
      IMAGE_ORGANIZATION: *organization
      IMAGE_REPOSITORY_BASE: *repository-base
      GITHUB_USERNAME:
        from_secret: GITHUB_USERNAME
      GITHUB_TOKEN:
        from_secret: GITHUB_TOKEN
    commands:
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        . "$ENV_FILE"

        if [ -z "$VERSIONS_TO_BUILD" ]; then
          echo "빌드할 버전이 없습니다. 스킵합니다."
          exit 0
        fi

        # 레지스트리 로그인
        echo "$GITHUB_TOKEN" | docker login "$IMAGE_REGISTRY" -u "$GITHUB_USERNAME" --password-stdin

        PLATFORM_SHORT="${platform##*/}"

        REGISTRY_IMAGE="$IMAGE_REGISTRY/$IMAGE_ORGANIZATION/$IMAGE_REPOSITORY_BASE"
        REGISTRY_STREAMING="$IMAGE_REGISTRY/$IMAGE_ORGANIZATION/$IMAGE_REPOSITORY_BASE-streaming"

        for VERSION_COMBO in $VERSIONS_TO_BUILD; do
          MASTODON_VER=`echo "$VERSION_COMBO" | cut -d: -f1`
          URI_VER=`echo "$VERSION_COMBO" | cut -d: -f2`

          IMAGE_NAME="mastodon-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}-$MASTODON_VER-$URI_VER"
          STREAMING_IMAGE_NAME="mastodon-streaming-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}-$MASTODON_VER-$URI_VER"

          # 플랫폼별 태그: vX.Y.Z-uriX.Y[-staging]-platform
          BASE_TAG="$MASTODON_VER-$URI_VER$TAG_SUFFIX-$PLATFORM_SHORT"

          # 플랫폼별 태그 푸시
          docker image tag "$IMAGE_NAME:latest" "$REGISTRY_IMAGE:$BASE_TAG"
          docker image tag "$STREAMING_IMAGE_NAME:latest" "$REGISTRY_STREAMING:$BASE_TAG"
          docker image push "$REGISTRY_IMAGE:$BASE_TAG"
          docker image push "$REGISTRY_STREAMING:$BASE_TAG"

          # 최신 버전인 경우 플랫폼별 latest 태그 추가
          if [ "$VERSION_COMBO" = "$LATEST_VERSION" ]; then
            LATEST_TAG="latest$TAG_SUFFIX-$PLATFORM_SHORT"
            docker image tag "$IMAGE_NAME:latest" "$REGISTRY_IMAGE:$LATEST_TAG"
            docker image tag "$STREAMING_IMAGE_NAME:latest" "$REGISTRY_STREAMING:$LATEST_TAG"
            docker image push "$REGISTRY_IMAGE:$LATEST_TAG"
            docker image push "$REGISTRY_STREAMING:$LATEST_TAG"
          fi
        done

        docker logout "$IMAGE_REGISTRY"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  # 정리
  - name: cleanup
    image: docker:cli
    commands:
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        . "$ENV_FILE"

        if [ -z "$VERSIONS_TO_BUILD" ]; then
          exit 0
        fi

        for VERSION_COMBO in $VERSIONS_TO_BUILD; do
          MASTODON_VER=`echo "$VERSION_COMBO" | cut -d: -f1`
          URI_VER=`echo "$VERSION_COMBO" | cut -d: -f2`

          IMAGE_NAME="mastodon-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}-$MASTODON_VER-$URI_VER"
          STREAMING_IMAGE_NAME="mastodon-streaming-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}-$MASTODON_VER-$URI_VER"

          docker image rm "$IMAGE_NAME:latest" || true
          docker image rm "$STREAMING_IMAGE_NAME:latest" || true
        done

        rm -f "$ENV_FILE"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    when:
      - status: [success, failure]

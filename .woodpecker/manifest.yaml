# 멀티 아키텍처 manifest 생성 워크플로우
# 모든 플랫폼 빌드가 완료된 후 실행되어 플랫폼 통합 태그 생성

variables:
  - &registry 'ghcr.io'
  - &organization 'uri-life'
  - &repository-base 'mastodon'

depends_on:
  - build

when:
  - event: push
    branch: main
    path:
      include:
        - 'versions/**'
        - 'manifest.yaml'
  - event: tag
    evaluate: 'CI_COMMIT_TAG matches "v[0-9]+\\.[0-9]+\\.[0-9]+([^+]+)?\\+uri[0-9]+\\.[0-9]+"'
  - event: manual
    branch: main

steps:
  # 버전 정보 추출
  - name: detect-versions
    image: alpine:latest
    commands:
      - apk add --no-cache git bash
      - scripts/detect-versions.sh "../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        # 이벤트 타입에 따른 태그 접미사 설정
        if [ "${CI_PIPELINE_EVENT}" = "tag" ]; then
          echo "IS_RELEASE=true" >> "$ENV_FILE"
          echo "TAG_SUFFIX=" >> "$ENV_FILE"
        else
          echo "IS_RELEASE=false" >> "$ENV_FILE"
          echo "TAG_SUFFIX=-staging" >> "$ENV_FILE"
        fi

  # 멀티 아키텍처 manifest 생성
  - name: create-manifest
    image: docker:cli
    environment:
      IMAGE_REGISTRY: *registry
      IMAGE_ORGANIZATION: *organization
      IMAGE_REPOSITORY_BASE: *repository-base
      GITHUB_USERNAME:
        from_secret: GITHUB_USERNAME
      GITHUB_TOKEN:
        from_secret: GITHUB_TOKEN
    commands:
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        source "$ENV_FILE"

        if [ -z "$VERSIONS_TO_BUILD" ]; then
          echo "빌드할 버전이 없습니다. 스킵합니다."
          exit 0
        fi

        # 레지스트리 로그인
        echo "$GITHUB_TOKEN" | docker login "$IMAGE_REGISTRY" -u "$GITHUB_USERNAME" --password-stdin

        REGISTRY_IMAGE="${IMAGE_REGISTRY}/${IMAGE_ORGANIZATION}/${IMAGE_REPOSITORY_BASE}"
        REGISTRY_STREAMING="${IMAGE_REGISTRY}/${IMAGE_ORGANIZATION}/${IMAGE_REPOSITORY_BASE}-streaming"

        for VERSION_COMBO in $VERSIONS_TO_BUILD; do
          MASTODON_VER=$(echo "$VERSION_COMBO" | cut -d: -f1)
          URI_VER=$(echo "$VERSION_COMBO" | cut -d: -f2)

          # 태그 정의 (staging일 경우 접미사 포함)
          MULTI_TAG="${MASTODON_VER}-${URI_VER}${TAG_SUFFIX}"
          AMD64_TAG="${MULTI_TAG}-amd64"
          ARM64_TAG="${MULTI_TAG}-arm64"

          echo "=== Manifest 생성: $MULTI_TAG ==="

          # Mastodon 메인 이미지 manifest 생성
          docker manifest create --amend "${REGISTRY_IMAGE}:${MULTI_TAG}" \
            "${REGISTRY_IMAGE}:${AMD64_TAG}" \
            "${REGISTRY_IMAGE}:${ARM64_TAG}"

          docker manifest annotate "${REGISTRY_IMAGE}:${MULTI_TAG}" \
            "${REGISTRY_IMAGE}:${AMD64_TAG}" --os linux --arch amd64

          docker manifest annotate "${REGISTRY_IMAGE}:${MULTI_TAG}" \
            "${REGISTRY_IMAGE}:${ARM64_TAG}" --os linux --arch arm64

          docker manifest push "${REGISTRY_IMAGE}:${MULTI_TAG}"

          # Streaming 이미지 manifest 생성
          docker manifest create --amend "${REGISTRY_STREAMING}:${MULTI_TAG}" \
            "${REGISTRY_STREAMING}:${AMD64_TAG}" \
            "${REGISTRY_STREAMING}:${ARM64_TAG}"

          docker manifest annotate "${REGISTRY_STREAMING}:${MULTI_TAG}" \
            "${REGISTRY_STREAMING}:${AMD64_TAG}" --os linux --arch amd64

          docker manifest annotate "${REGISTRY_STREAMING}:${MULTI_TAG}" \
            "${REGISTRY_STREAMING}:${ARM64_TAG}" --os linux --arch arm64

          docker manifest push "${REGISTRY_STREAMING}:${MULTI_TAG}"

          # 최신 버전인 경우 latest manifest 생성
          if [ "$VERSION_COMBO" = "$LATEST_VERSION" ]; then
            LATEST_TAG="latest${TAG_SUFFIX}"
            echo "=== 최신 버전입니다. ${LATEST_TAG} manifest 생성 ==="

            # Mastodon latest manifest
            docker manifest create --amend "${REGISTRY_IMAGE}:${LATEST_TAG}" \
              "${REGISTRY_IMAGE}:${LATEST_TAG}-amd64" \
              "${REGISTRY_IMAGE}:${LATEST_TAG}-arm64"

            docker manifest annotate "${REGISTRY_IMAGE}:${LATEST_TAG}" \
              "${REGISTRY_IMAGE}:${LATEST_TAG}-amd64" --os linux --arch amd64

            docker manifest annotate "${REGISTRY_IMAGE}:${LATEST_TAG}" \
              "${REGISTRY_IMAGE}:${LATEST_TAG}-arm64" --os linux --arch arm64

            docker manifest push "${REGISTRY_IMAGE}:${LATEST_TAG}"

            # Streaming latest manifest
            docker manifest create --amend "${REGISTRY_STREAMING}:${LATEST_TAG}" \
              "${REGISTRY_STREAMING}:${LATEST_TAG}-amd64" \
              "${REGISTRY_STREAMING}:${LATEST_TAG}-arm64"

            docker manifest annotate "${REGISTRY_STREAMING}:${LATEST_TAG}" \
              "${REGISTRY_STREAMING}:${LATEST_TAG}-amd64" --os linux --arch amd64

            docker manifest annotate "${REGISTRY_STREAMING}:${LATEST_TAG}" \
              "${REGISTRY_STREAMING}:${LATEST_TAG}-arm64" --os linux --arch arm64

            docker manifest push "${REGISTRY_STREAMING}:${LATEST_TAG}"
          fi
        done

        docker logout "$IMAGE_REGISTRY"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  # 정리
  - name: cleanup
    image: docker:cli
    commands:
      - |
        ENV_FILE="../.ci-${CI_PIPELINE_PARENT}-${CI_PIPELINE_NUMBER}.env"
        rm -f "$ENV_FILE"
    when:
      - status: [success, failure]
